#!/usr/bin/env python3
# distutils: language=c


"""tgp.pyx: Target Generation Process. Automatically creates N most significant targets in target detection for pixel classification"""

# --------------------------------------------------------------------------------------------
# Imports
# --------------------------------------------------------------------------------------------
import numpy as np
cimport numpy as np

from typing import List, Tuple
from logging import warn, info
from dataclasses import dataclass
from tqdm import tqdm

from ..build.math_utils import (
    compute_orthogonal_complement_matrix, 
    compute_opci, 
    project_block_onto_subspace,
)
from ..build.rastio import MultibandBlockReader


# --------------------------------------------------------------------------------------------
# Authorship Information
# --------------------------------------------------------------------------------------------
__author__ = "Gian-Mateo (GM) Tifone"
__copyright__ = "2025, RIT MISHA"
__credits__ = ["Gian-Mateo Tifone"]
__license__ = "MIT"
__version__ = "3.2.0"
__maintainer__ = "MISHA Team"
__email__ = "mt9485@rit.edu"
__status__ = "Development" # "Prototype", "Development", "Production"


# --------------------------------------------------------------------------------------------
# Custom Datatypes
# --------------------------------------------------------------------------------------------
WindowType = np.ndarray

ctypedef np.float32_t float_t
ctypedef Py_ssize_t psize_t

@dataclass
class Target:
    value: float
    row: int
    col: int
    band_spectrum: np.ndarray  # shape (bands,)


# --------------------------------------------------------------------------------------------
# C Helper Functions
# --------------------------------------------------------------------------------------------
cdef int[:,:] _generate_windows_cy(
    int img_height, 
    int img_width, 
    int win_height, 
    int win_width
):
    """
    Generate window offsets and sizes for an image.
    
    Returns:
        windows: int[:, :] memoryview of shape (total_windows, 4)
                 Each row: (row_off, col_off, actual_height, actual_width)
    """
    cdef:
        int n_rows = (img_height + win_height - 1) // win_height
        int n_cols = (img_width + win_width - 1) // win_width
        int total_windows = n_rows * n_cols
        int[:, :] win_mv
        np.ndarray[int, ndim=2] windows = np.empty((total_windows, 4), dtype=np.int32)
    
    win_mv = windows

    cdef int row_idx, col_idx, win_idx
    cdef int row_off, col_off, actual_height, actual_width

    win_idx = 0
    for row_idx in range(n_rows):
        for col_idx in range(n_cols):
            row_off = row_idx * win_height
            col_off = col_idx * win_width

            actual_height = win_height
            if row_off + win_height > img_height:
                actual_height = img_height - row_off

            actual_width = win_width
            if col_off + win_width > img_width:
                actual_width = img_width - col_off

            # Fill window valuess
            win_mv[win_idx, 0] = row_off
            win_mv[win_idx, 1] = col_off
            win_mv[win_idx, 2] = actual_height
            win_mv[win_idx, 3] = actual_width

            win_idx += 1

    return win_mv


def _best_target_cy(
    list src_bands_path,
    int[:,:] win_mv,
    np.ndarray p_matrix = None,
) -> Target:
    """
    Computes candidate targets for each block, and returns the best (largest L2 norm)
    target, as dataclass Target.

    Args:
        paths (list): Input paths
        win_mv (int[:,:]): Memory view of windows as generated by _generate_windows_cy
        p_matrix (float32[:,:]): Projection matrix. Is None for first target.  
    """
    cdef:
        int total_windows = win_mv.shape[0]
        int i, row_off, col_off, win_h, win_w

        float_t cur_val
        psize_t cur_idx
        float_t best_val = <float_t> (-3.3e38)
        # Local best variables
        int best_row = -1
        int best_col = -1
        int best_win_row_off = 0
        int best_win_col_off = 0
        # Memory view
        float_t[:, :, :] block_mv  

    # Python objects (must be handled with the GIL)
    best_spec: np.ndarray = np.empty(0, dtype=np.float32)

    # Open the reader once and iterate windows
    with MultibandBlockReader(src_bands_path) as reader:
        for i in range(total_windows):
            # Build the window tuple: ((row_off, col_off), (height, width))
            row_off = <int> win_mv[i, 0]
            col_off = <int> win_mv[i, 1]
            win_h   = <int> win_mv[i, 2]
            win_w   = <int> win_mv[i, 3]
            # Read block from window
            win = np.array([row_off, col_off, win_h, win_w], dtype=np.int32)
            block = reader.read_multiband_block(win)

            # Ensure C contiguous
            if not block.flags['C_CONTIGUOUS']:
                block = np.ascontiguousarray(block, dtype=np.float32)

            # Optional projection (kept in Python/GIL)
            if p_matrix is not None:
                proj_block = project_block_onto_subspace(block, p_matrix)
            else:
                proj_block = block

            # Find maximum L2 norm across entire block
            block_mv = proj_block
            with nogil:
                argmax_l2_norms(block_mv, &cur_val, &cur_idx)

            # Update best if current is better
            if cur_val > best_val:
                best_val = cur_val
                best_row, best_col = divmod(<int>cur_idx, win_w)
                best_win_row_off = row_off
                best_win_col_off = col_off
                best_spec = block[:, best_row, best_col] 

    # Build and return the Target (Python object)
    return Target(
        float(best_val),
        best_win_row_off + best_row,
        best_win_col_off + best_col,
        best_spec)


cdef int argmax_l2_norms(
    float_t[:, :, :] block_mv,   # shape: (bands, height, width)
    float_t* out_max_val,        # [output] max L2^2 value (squared norm)
    psize_t* out_flat_idx        # [output] flat index (row * width + col)
) nogil:
    """
    Compute the pixel with the maximum L2 norm in a hyperspectral block,
    without allocating any temporary arrays.

    Args:
        block_mv : float32[:, :, :]
            Typed memoryview of the block (bands, height, width).
        out_max_val : float32*
            Pointer to write the maximum **squared** L2 norm (sum of squares).
            Use pointer indexing, e.g. out_max_val[0] = value.
        out_flat_idx : Py_ssize_t*
            Pointer to write the flat index of the argmax pixel (row * width + col).


    Returns:
        int: Allows cdef to throw error code.
    """
    cdef:
        psize_t bands = block_mv.shape[0]
        psize_t height = block_mv.shape[1]
        psize_t width  = block_mv.shape[2]
        psize_t row, col, b
        float_t acc
        float_t max_val = -3.3e38
        psize_t max_idx = 0
        psize_t flat_idx

    for row in range(height):
        for col in range(width):
            acc = 0.0
            for b in range(bands):
                acc += block_mv[b, row, col] * block_mv[b, row, col]

            flat_idx = row * width + col
            if acc > max_val:
                max_val = acc
                max_idx = flat_idx

    out_max_val[0] = max_val
    out_flat_idx[0] = max_idx


# --------------------------------------------------------------------------------------------
# TGP Function
# --------------------------------------------------------------------------------------------
def target_generation_process(
    *,
    generated_bands:List[str],
    window_shape:Tuple[int,int],
    max_targets:int,
    opci_threshold:float,
    verbose:bool
) -> List[np.ndarray]:
    """
    Iteratively projects image into orthogonal subspace and extracts new target vectors
    until OPCI falls below a threshold or a max target count is reached.

    Args:
        generated_bands (List[str]): 
            Path to gen_band_norm.tif i.e. </path/to/gen_band_norm.tif>
        window_shape (Tuple[int,int]):
            Size of tile ("block") of data to process.
        max_targets (int, optional): 
            Max number of targets to extract. Defaults to 10.
        opci_threshold (float, optional): 
            Stop if OPCI of target falls below this. Bigger number = less targets.
            Higher threshold (e.g. 0.1) creates less pure targets.
            Lower threshold (e.g. 0.001) creates more pure targets.

    Returns:
        List[np.ndarray]: List of targets (T0, T1, T2, ...); 
    """
    cdef:
        int win_height = <int> window_shape[0] 
        int win_width  = <int> window_shape[1]
        int img_height, img_width
        int[:,:] win_mv
        np.ndarray p_matrix
        float_t opci

    targets:List[np.ndarray] = []
    

    # ==============================
    # Image size & window dimensions
    # ==============================
    if verbose: info("[TGP] Getting image dimensions ...")
    with MultibandBlockReader(generated_bands) as reader:
        img_height, img_width = reader.image_shape


    # ============================================================
    # Generate windows
    # ============================================================
    if verbose: info("[TGP] Generating windows ...")
    # Generate array of window dimensions (num_windows, 4) 
    win_mv = _generate_windows_cy(img_height, img_width, win_height, win_width)
    

    # =================================
    # Find the first target T0 and OPCI
    # =================================
    if verbose: info("[TGP] Finding first target ...")
    T0 = _best_target_cy(
        src_bands_path=generated_bands, 
        p_matrix=None,
        win_mv=win_mv,
    )
    targets.append(T0.band_spectrum)

    
    # =========================================
    # Iterate for subsequence targets (t1...tk)
    # =========================================
    if verbose: info("[TGP] Iterating for subsequent targets ...")
    for _ in tqdm(range(1, max_targets), desc="[TGP] Generating targets", unit="target", colour="MAGENTA"):
        p_matrix = compute_orthogonal_complement_matrix(targets)
        best_target = _best_target_cy(
            src_bands_path=generated_bands,
            win_mv=win_mv,
            p_matrix=p_matrix
        )

        # Evaluate OPCI
        opci = compute_opci(p_matrix, best_target.band_spectrum)
        if not np.isfinite(opci):
            warn("[TGP] OPCI reached infinity; exiting.")
            opci = 0.0
        if opci < opci_threshold:
            if verbose: print("[TGP] OPCI below threshold; stopping.")
            break

        targets.append(best_target.band_spectrum)

    return targets
